Matrix Subtraction

#include <iostream>
using namespace std;
int main()
{
int m, n, c, d, first[10][10], second[10][10], difference[10][10];

cout<<"Enter the number of rows and columns of matrix\n";
cin>>m>>n;
cout<<"Enter the elements of first matrix\n";

for (c = 0; c < m; c++)
for (d = 0 ; d < n; d++)
cin>>first[c][d];

cout<<"Enter the elements of second matrix\n";

for (c = 0; c < m; c++)
for (d = 0; d < n; d++)
cin>>second[c][d];

for (c = 0; c < m; c++)
for (d = 0; d < n; d++)
difference[c][d] = first[c][d] - second[c][d];
/* Subtract Matrices*/

cout<<"difference of entered matrices:-\n";

for (c = 0; c < m; c++)
{
for (d = 0; d < n; d++)
cout<<difference[c][d]<<"\t";

cout<<"\n";
} return 0; }

/*
Output:
Enter the number of rows and columns of matrix                                     
2                                                                                  
2                                                                                  
Enter the elements of first matrix                                                 
1 1                                                                                
1 1                                                                                
Enter the elements of second matrix                                                
2 2                                                                                
2 2                                                                                
difference of entered matrices:-                                                          
-1       -1                                                                          
-1       -1 
*/



operator overloading

#include <iostream>
using namespace std;

class Cube
{
public:

void setLength( double l )
{
length = l;
}

void setBreadth( double b )
{
breadth = b;
}

void setHeight( double h )
{
height = h;
}
double getVolume(void)
{
return length * breadth * height;
}

// Overload + operator to add two Cube objects.
Cube operator+(const Cube& b)
{
Cube C;
C.length = this->length + b.length;
C.breadth = this->breadth + b.breadth;
C.height = this->height + b.height;
return C;
}
private:
double length; // Length of a Cube
double breadth; // Breadth of a Cube
double height; // Height of a Cube
};
// Main function for the program
int main( )
{
Cube C1; // Declare C1 of type Cube
Cube C2; // Declare C2 of type Cube
Cube C3; // Declare C3 of type Cube
double volume = 0.0; // Store the volume of a Cube here

// Cube 1 specification
C1.setLength(4.0);
C1.setBreadth(6.0);
C1.setHeight(5.0);

// Cube 2 specification
C2.setLength(8.0);
C2.setBreadth(4.0);
C2.setHeight(10.0);

// volume of Cube 1
volume = C1.getVolume();
cout << "Volume of Cube 1 : " << volume <<endl;

// volume of Cube 2
volume = C2.getVolume();
cout << "Volume of Cube 2 : " << volume <<endl;

// Add two object as follows:
C3 = C1 + C2;

// volume of Cube 3
volume = C3.getVolume();
cout << "Volume of Cube 3 : " << volume <<endl;

return 0;
}


Output:

volume of Cube 1 : 120
Volume of Cube 2 : 320
Volume of Cube 3 : 1800

Download this app for more programs and tutorials
https://play.google.com/store/apps/details?id=com.codetoinvent.malik.cplusplus
Unary operator overloading

#include <iostream>
using namespace std;

class Distance
{
private:
int feet; // 0 to infinite
int inches; // 0 to 12
public:
// required constructors
Distance(){
feet = 0;
inches = 0;
}
Distance(int f, int i){
feet = f;
inches = i;
}
// method to display distance
void displayDistance()
{
cout << "F: " << feet << " I:" << inches <<endl;
}
// overloaded minus (-) operator
Distance operator- ()
{
feet = -feet;
inches = -inches;
return Distance(feet, inches);
}
};
int main()
{
Distance D1(4,7), D2(-5, 3),D3(10,-2);

-D1; // apply negation
D1.displayDistance(); // display D1

-D2; // apply negation
D2.displayDistance(); // display D2

-D3; // apply negation
D3.displayDistance(); // display D3

return 0;
}


Output:

F: -4 I: -7
F: 5 I: -3
F: -10 I: 2

Download this app for more programs and tutorials
https://play.google.com/store/apps/details?id=com.codetoinvent.malik.cplusplus
Binary operator overloading

#include <iostream>
using namespace std;

class Cube
{
public:

void setLength( double l )
{
length = l;
}

void setBreadth( double b )
{
breadth = b;
}

void setHeight( double h )
{
height = h;
}
double getVolume(void)
{
return length * breadth * height;
}

// Overload + operator to add two Cube objects.
Cube operator+(const Cube& b)
{
Cube C;
C.length = this->length + b.length;
C.breadth = this->breadth + b.breadth;
C.height = this->height + b.height;
return C;
}
private:
double length; // Length of a Cube
double breadth; // Breadth of a Cube
double height; // Height of a Cube
};
// Main function for the program
int main( )
{
Cube C1; // Declare C1 of type Cube
Cube C2; // Declare C2 of type Cube
Cube C3; // Declare C3 of type Cube
double volume = 0.0; // Store the volume of a Cube here

// Cube 1 specification
C1.setLength(4.0);
C1.setBreadth(6.0);
C1.setHeight(5.0);

// Cube 2 specification
C2.setLength(8.0);
C2.setBreadth(4.0);
C2.setHeight(10.0);

// volume of Cube 1
volume = C1.getVolume();
cout << "Volume of Cube 1 : " << volume <<endl;

// volume of Cube 2
volume = C2.getVolume();
cout << "Volume of Cube 2 : " << volume <<endl;

// Add two object as follows:
C3 = C1 + C2;

// volume of Cube 3
volume = C3.getVolume();
cout << "Volume of Cube 3 : " << volume <<endl;

return 0;
}


Output:

Volume of Cube 1 : 120
Volume of Cube 2 : 320
Volume of Cube 3 : 1800

Download this app for more programs and tutorials
https://play.google.com/store/apps/details?id=com.codetoinvent.malik.cplusplus
Assignment operator

#include <iostream>

using namespace std;
const int MAX = 5;

int main ()
{
int arr[MAX] = {10,20,30,40,50};
int *ptr[MAX];

for (int i = 0; i < MAX; i++)
{
ptr[i] = &arr[i]; // assign the address of integer.
}
for (int i = 0; i < MAX; i++)
{
cout << "Value of var[" << i << "] = " << *ptr[i] << endl;
}
return 0;
}


Output:

Value of var[0] = 10
Value of var[1] = 20
Value of var[2] = 30
Value of var[3] = 40
Value of var[4] = 50

Download this app for more programs and tutorials
https://play.google.com/store/apps/details?id=com.codetoinvent.malik.cplusplus
Relational operator

#include <iostream>
using namespace std;

class Distance
{
private:
int feet; // 0 to infinite
int inches; // 0 to 12
public:
// required constructors
Distance(){
feet = 0;
inches = 0;
}
Distance(int f, int i){
feet = f;
inches = i;
}
// method to display distance
void displayDistance()
{
cout << "F: " << feet << " I:" << inches <<endl;
}
// overloaded minus (-) operator
Distance operator- ()
{
feet = -feet;
inches = -inches;
return Distance(feet, inches);
}
// overloaded < operator
bool operator <(const Distance& d)
{
if(feet < d.feet)
{
return true;
}
if(feet == d.feet && inches < d.inches)
{
return true;
}
return false;
}
};
int main()
{
Distance D1(4,7), D2(-5, 3);

if( D1 < D2 )
{
cout << "D1 is less than D2 " << endl;
}
else
{
cout << "D2 is less than D1 " << endl;
}
return 0;
}


Output:

D2 is less than D1

Download this app for more programs and tutorials
https://play.google.com/store/apps/details?id=com.codetoinvent.malik.cplusplus
stack using array

/*

A stack is an abstract data structure that contains a collection of elements. Stack implements the LIFO mechanism i.e. the element that is pushed at the end is popped out first. Some of the principle operations in the stack are -

* Push - This adds a data value to the top of the stack.

* Pop - This removes the data value on top of the stack

* Peek - This returns the top data value of the stack A program that implements a stack using array is given as follows.

*/

#include <iostream>

using namespace std;

int stack[100], n=100, top=-1;

void push(int val) {

if(top>=n-1)

cout<<"Stack Overflow"<<endl;

else { top++; stack[top]=val;

}

}

void pop() {

if(top<=-1)

cout<<"Stack Underflow"<<endl;

else {

cout<<"The popped element is "<< stack[top] <<endl;

top--;

}

}

void display() {

if(top>=0) {

cout<<"Stack elements are:";

for(int i=top; i>=0; i--)

cout<<stack[i]<<" ";

cout<<endl;

}

else cout<<"Stack is empty";

}

int main() {

int ch, val;

cout<<"1) Push in stack"<<endl;

cout<<"2) Pop from stack"<<endl;

cout<<"3) Display stack"<<endl;

cout<<"4) Exit"<<endl;

do {

cout<<"Enter choice: "<<endl;

cin>>ch;

switch(ch) {

case 1: 

cout<<"Enter value to be pushed:"<<endl;

cin>>val;

push(val);

break; 

 case 2:  pop(); break; 

 case 3:  display(); break; 

 case 4:  cout<<"Exit"<<endl; break; 

 default: cout<<"Invalid Choice"<<endl; 

} }

while(ch!=4);

return 0;

}



Output:

1) Push in stack

2) Pop from stack

3) Display stack

4) Exit Enter choice: 1

Enter value to be pushed: 2

Enter choice: 1

Enter value to be pushed: 6

Enterchoice: 1

Enter value to be pushed: 8

Enter choice: 1

Enter value to be pushed: 7

Enter choice: 2

The popped element is 7

Enter choice: 3

Stack elements are:8 6 2

Enter choice: 5

Invalid Choice Enter choice: 4

Exit

Download this app for more programs and tutorials
https://play.google.com/store/apps/details?id=com.codetoinvent.malik.cplusplus
queue using array

#include <iostream>

using namespace std;

int queue[100], n = 100, front = - 1, rear = - 1;

void Insert() {

int val;

if (rear == n - 1)

cout<<"Queue Overflow"<<endl;

else {

if (front == - 1)

front = 0;

cout<<"Insert the element in queue : "<<endl;

cin>>val;

rear++;

queue[rear] = val;

}

}

void Delete() {

if (front == - 1 || front > rear) {

cout<<"Queue Underflow ";

return ;

}

else {

cout<<"Element deleted from queue is : "<< queue[front] <<endl;

front++;

}     }

void Display() {

if (front == - 1)

cout<<"Queue is empty"<<endl;

else {

cout<<"Queue elements are : ";

for (int i = front; i <= rear; i++)

cout<<queue[i]<<" ";

cout<<endl;

}

}

int main() {

int ch;

cout<<"1) Insert element to queue"<<endl;

cout<<"2) Delete element from queue"<<endl;

cout<<"3) Display all the elements of queue"<<endl;

cout<<"4) Exit"<<endl;

do {

cout<<"Enter your choice : "<<endl;

cin>>ch;

switch (ch) {

case 1: Insert();

break;

case 2: Delete();

break;

case 3: Display();       break;

case 4: cout<<"Exit"<<endl;    break;

default: cout<<"Invalid choice"<<endl;

}  }

while(ch!=4);

return 0;

}



Output:

1) Insert element to queue

2) Delete element from queue

3) Display all the elements of queue

4) Exit Enter your choice : 1

Insert the element in queue : 4

Enter your choice : 1 Insert the element in queue : 3

Enter your choice : 1 Insert the element in queue : 5

Enter your choice : 2

Element deleted from queue is : 4

Enter your choice : 3

Queue elements are : 3 5

Enter your choice : 7

Invalid choice Enter your choice : 4

Exit

Download this app for more programs and tutorials
https://play.google.com/store/apps/details?id=com.codetoinvent.malik.cplusplus
stack using linkedlist

#include<iostream>

using namespace std;

// Creating a NODE Structure

struct node {

int data;

struct node *next;

};

// Creating a class STACK

class stack {

struct node *top;

public: stack() // constructor {

top=NULL; }

void push();

// to insert an element

void pop(); // to delete an element

void show(); // to show the stack };

// PUSH Operation void stack::push() {

int value;

struct node *ptr;

cout<<"\nPUSH Operationn";

cout<<"Enter a number to insert: ";

cin>>value;

ptr=new node;

ptr->data=value;

ptr->next=NULL;

if(top!=NULL) ptr->next=top;

top=ptr;

cout<<"\nNew item is inserted to the stack!!!";

}

// POP Operation

void stack::pop() {

struct node *temp;

if(top==NULL) {

cout<<"\nThe stack is empty!!!"; }

temp=top; top=top->next;

cout<<"\nPOP Operation........\nPoped value is "<<temp->data;

delete temp;

}

// Show stack

void stack::show() {

struct node *ptr1=top;

cout<<"\nThe stack is\n";

while(ptr1!=NULL) {

cout<<ptr1->data<<" ->";

ptr1=ptr1->next;

}

cout<<"NULL\n";

}

// Main function

int main() {

stack s;

int choice;

while(1) {

cout<<"\n-----------------------------------------------------------"; cout<<"\n\t\tSTACK USING LINKED LIST\n\n"; cout<<"1:PUSH\n2:POP\n3:DISPLAY STACK\n4:EXIT";

cout<<"\nEnter your choice(1-4): ";

cin>>choice;

switch(choice) {

case 1: s.push(); break;

case 2: s.pop(); break;

case 3: s.show(); break;

case 4: return 0;

break;

default: cout<<"\nPlease enter correct choice(1-4)!!";

break;

}

}

return 0;

}



Output:

STACK USING LINKED LIST 1:PUSH 2:POP 3:DISPLAY STACK 4:EXIT Enter your choice(1-4): 1 PUSH Operation Enter a number to insert: 12 New item is inserted to the stack!!! ----------------------------------------------------------- STACK USING LINKED LIST 1:PUSH 2:POP 3:DISPLAY STACK 4:EXIT Enter your choice(1-4): 1 PUSH Operation Enter a number to insert: 5 New item is inserted to the stack!!! ----------------------------------------------------------- STACK USING LINKED LIST 1:PUSH 2:POP 3:DISPLAY STACK 4:EXIT Enter your choice(1-4): 2 POP Operation........ Poped value is 5 ----------------------------------------------------------- STACK USING LINKED LIST 1:PUSH 2:POP 3:DISPLAY STACK 4:EXIT Enter your choice(1-4): 3 The stack is 12 ->NULL ----------------------------------------------------------- STACK USING LINKED LIST 1:PUSH 2:POP 3:DISPLAY STACK 4:EXIT Enter your choice(1-4): 4

Download this app for more programs and tutorials
https://play.google.com/store/apps/details?id=com.codetoinvent.malik.cplusplus
queue using linkedlist

 #include<iostream>

using namespace std;

struct node {

int data;

node *next;

}*front = NULL,*rear = NULL,*p = NULL,*np = NULL;

void push(int x) {

np = new node;

np->data = x;

np->next = NULL;

if(front == NULL) {

front = rear = np;

rear->next = NULL;

}

else {

rear->next = np;

rear = np;

rear->next = NULL;

}

}

int remove() {

int x;

if(front == NULL) {

cout<<"empty queuen"; }

else

{

p = front;   x = p->data;

front = front->next;

delete(p);

return(x);

}

}

int main() {

int n,c = 0,x;

cout<<"Enter the number of values to be pushed into queuen";

cin>>n;

while (c < n) {

cout<<"Enter the value to be entered into queuen";

cin>>x;

push(x);

c++;

}

cout<<"Removed Values";

while(true) {

if (front != NULL)

cout<<remove()<<endl;

else break;

}

return 0;

}



Output:

Enter the number of values to be pushed into queue 5

Enter the value to be entered into queue 5

Enter the value to be entered into queue 3

Enter the value to be entered into queue 2

Enter the value to be entered into queue 9

Enter the value to be entered into queue 1

Removed Values 5 3 2 9 1

Download this app for more programs and tutorials
https://play.google.com/store/apps/details?id=com.codetoinvent.malik.cplusplus
Virtual function

// C++ program to illustrate

// concept of Virtual Functions 

#include<iostream>

using namespace std;

class base {

public: virtual void print () {

cout<< "print base class" <<endl; }

void show () {

cout<< "show base class" <<endl; }

};

class derived:public base {

public: void print () {

cout<< "print derived class" <<endl; }

void show () {

cout<< "show derived class" <<endl; }

};

int main() {

base *bptr; derived d; bptr = &d;

//virtual function, binded at runtime

bptr->print();

// Non-virtual function, binded at compile time

bptr->show(); }



Output:

print derived class show base class

Download this app for more programs and tutorials
https://play.google.com/store/apps/details?id=com.codetoinvent.malik.cplusplus
Reference as parameter

#include <iostream>
using namespace std;

// function declaration with reference
void swap(int& x, int& y);

int main ()
{
int a = 10;
int b = 20;

cout << "Value of a Before swapping :" << a << endl;
cout << "Value of b Before swapping :" << b << endl;

/* Function call */
swap(a, b);

cout << "Value of a After swapping :" << a << endl;
cout << "Value of b After swapping :" << b << endl;

return 0;
}

void swap(int& x, int& y) //reference variable is as parameter to the function
{
int temp;
temp = x;
x = y;
y = temp;

return;
}


Output:

Value of a Before swapping :10
Value of b Before swapping :20
Value of a After swapping :20
Value of b After swapping :10

Download this app for more programs and tutorials
https://play.google.com/store/apps/details?id=com.codetoinvent.malik.cplusplus
pointer values and adress

#include <iostream>

using namespace std;

int main ()
{
int var = 10; // Variable Declaration
int *ip; // variable for Pointer

ip = &var; // address of variable is stored in pointer variable

cout << "Value of var variable: ";
cout << var << endl; //Print value of variable

// Print the address of variable
cout << "Address stored in ip variable: ";
cout << ip << endl;

// access the value at the address available in pointer
cout << "Value of *ip variable: ";
cout << *ip << endl;

return 0;
}


Output:

Value of var variable: 10
Address stored in ip variable: 0x22ff44
Value of *ip variable: 10

Download this app for more programs and tutorials
https://play.google.com/store/apps/details?id=com.codetoinvent.malik.cplusplus
nCr & nPr

#include <iostream>
using namespace std;
long factorial(int);
long find_ncr(int, int);
long find_npr(int, int);

main()
{
int n, r;
long ncr, npr;

cout<<"Enter the value of n and r\n";
cin>>n>>r;

ncr = find_ncr(n, r);
npr = find_npr(n, r);

cout<<n<<"C"<<r<<" ="<<ncr<<"\n";
cout<<n<<"P"<<r<<"=" <<npr<<"\n";

return 0;
}

long find_ncr(int n, int r)
{
long result;

result = factorial(n)/(factorial(r)*factorial(n-r));

return result;
}

long find_npr(int n, int r)
{
long result;

result = factorial(n)/factorial(n-r);

return result;
}

long factorial(int n)
{
int c;
long result = 1;
for( c = 1 ; c <= n ; c++ )
result = result*c;
return ( result );
}


Output:

Enter the value of n and r                                                         
2                                                                                  
3                                                                                  
2C3 =0                                                                             
2P3=2  

Download this app for more programs and tutorials
https://play.google.com/store/apps/details?id=com.codetoinvent.malik.cplusplus


LCM & HCF

#include <iostream>
using namespace std;
long gcd(long, long);
int main() {
long x, y, hcf, lcm;

cout<<"Enter two integers\n";
cin>>x>>y;

hcf = gcd(x, y);
lcm = (x*y)/hcf;

cout<<"Greatest common divisor of "<<x <<"and"<<y<<" = "<<hcf<<"\n";
cout<<"Least common multiple of "<< x <<"and "<< y<<"= "<<lcm<<"\n";

return 0;
}

/*if 1st no is 0 then 2nd no is gcd
make 2nd no 0 by subtracting smallest from largest and return 1st no as gcd*/
long gcd(long x, long y) {
if (x == 0) {
return y;
}

while (y != 0) {
if (x > y) {
x = x - y;
}
else {
y = y - x;
}
}

return x;
}


Output:

Enter two integers                                                                 
4 7                                                                                
Greatest common divisor of 4and7 = 1                                               
Least common multiple of 4and 7= 28 

Download this app for more programs and tutorials
https://play.google.com/store/apps/details?id=com.codetoinvent.malik.cplusplus
Armstrong num

#include <iostream>
using namespace std;
int main()
{
int r;
long number = 0, c, sum = 0, temp;

cout<<"Enter an integer upto which you want to find armstrong numbers\n";
cin>>number;

cout<<"Following armstrong numbers are found from 1 to"<<number<<"\n";

/if sum of cubes of each digit in a number is same as the number then it is called as armstrong no./
for( c = 1 ; c <= number ; c++ )
{
temp = c;
while( temp != 0 )
{
r = temp%10;
sum = sum + r*r*r;
temp = temp/10;
/taking unit place digits cube and adding into sum/
}
if ( c == sum )
cout<<c<<"\n";
/If no is Armstrong no then print/
sum = 0;
}

return 0;
}


Output:

Enter an integer upto which you want to find armstrong numbers                     
9000                                                                               
Following armstrong numbers are found from 1 to9000                                
1                                                                                  
153                                                                                
370                                                                                
371                                                                                
407 

Download this app for more programs and tutorials
https://play.google.com/store/apps/details?id=com.codetoinvent.malik.cplusplus



dynamic memory allocation(constructor & destructor)

#include <iostream>
using namespace std;

class Cube
{
public:
Cube() {
cout << "Constructor is called!" <<endl;
}
~Cube() {
cout << "Destructor is called!" <<endl;
}
};

int main( )
{
Cube* myCubeArray = new Cube[5];

delete [] myCubeArray; // Delete array

return 0;
}

/*
Output:
Constructor is called!
Constructor is called!
Constructor is called!
Constructor is called!
Constructor is called!
Destructor is called!
Destructor is called!
Destructor is called!
Destructor is called!
Destructor is called!*/


